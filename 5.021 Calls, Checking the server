Start up a roscore and then run the action server:

  user@hostname$ rosrun basics simple_action_server.py

Let’s check that the expected topics are present:

  user@hostname$ rostopic list
  /rosout
  /rosout_agg
  /timer/cancel
  /timer/feedback
  /timer/goal
  /timer/result
  /timer/status

  That looks good: we can see the five topics in the timer namespace that are used
  under the hood to manage the action.

Let’s take a closer look at the /timer/goal topic, using rostopic:

  user@hostname$ rostopic info /timer/goal
  Type: basics/TimerActionGoal

  Publishers: None

  Subscribers:
    * /timer_action_server (http://localhost:63174/)
  
What’s a TimerActionGoal? Let’s dig in further, now with rosmsg:

  user@hostname$ rosmsg show TimerActionGoal
  [basics/TimerActionGoal]:
  std_msgs/Header header
    uint32 seq
    time stamp
    string frame_id
  actionlib_msgs/GoalID goal_id
    time stamp
    string id
  basics/TimerGoal goal
    duration time_to_wait

Interesting; we can see our goal definition in there, as the goal.time_to_wait field,
but there are also some extra fields that we didn’t specify. Those extra fields are used
by the action server and client code to keep track of what’s happening. Fortunately,
that bookkeeping information is automatically stripped away before our server code
sees a goal message.

While a TimerActionGoal message is sent over the wire, what we 
see in our goal execution is a bare TimerGoal message, which is just what we defined
in our .action file:

  user@hostname$ rosmsg show TimerGoal
  [basics/TimerGoal]:
  duration time_to_wait

In general, if you’re using the libraries in the actionlib package, you should not need
to access the autogenerated messages with Action in their type name. The bare Goal,
Result, and Feedback messages should suffice.

If you like, you can publish and subscribe directly to an action server’s topics using
the autogenerated Action message types. This is a nice feature of ROS actions: they
are just a higher-level protocol built on top of ROS messages. But for most applications, 
the actionlib libraries will do the job, handling the underlying messages for you behind the scenes.
